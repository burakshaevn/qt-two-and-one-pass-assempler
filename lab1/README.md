# Двухпросмотровый ассемблер

## Описание

Это приложение представляет собой двухпросмотровый ассемблер для абсолютных программ с графическим интерфейсом, написанный на C++ с использованием Qt. Программа позволяет:

- Вводить исходный код ассемблера
- Настраивать таблицу команд
- Выполнять первый проход ассемблера (создание таблицы символических имен)
- Выполнять второй проход ассемблера (генерация объектного кода)
- Отображать ошибки проходов

> [!IMPORTANT] 
> **Абсолютные программы** — это программы, которые загружаются с конкретного адреса памяти и в дальнейшем не могут быть перемещены в другую область памяти. Поэтому в контексте этой программы нельзя задать адрес расположения `PROG  START   0`, потому что это нарушает основное свойство абсолютных программ — их привязку к конкретным адресам памяти. Если абсолютную программу загрузить не по тому адресу, для которого она была создана, все внутренние ссылки и адресация станут некорректными, что приведет к выполнению неверных команд или обращению к wrong данным.

## Структура проекта

```
QtAssembler/
├── CMakeLists.txt          # Файл сборки CMake
├── README.md               # Этот файл
├── include/                # Заголовочные файлы
│   ├── ui/
│   │   └── mainwindow.h
│   ├── assembler/
│   │   └── assembler.h
│   ├── parser/
│   │   └── parser.h
│   ├── structures/
│   │   ├── command.h
│   │   ├── operand.h
│   │   ├── symbolicname.h
│   │   └── codeline.h
│   └── exceptions/
│       └── assemblerexception.h
├── src/                    # Исходные файлы
│   ├── main.cpp
│   ├── ui/
│   │   └── mainwindow.cpp
│   ├── assembler/
│   │   └── assembler.cpp
│   ├── parser/
│   │   └── parser.cpp
│   ├── structures/
│   │   ├── command.cpp
│   │   ├── operand.cpp
│   │   ├── symbolicname.cpp
│   │   └── codeline.cpp
│   └── exceptions/
│       └── assemblerexception.cpp
└── ui/                     # UI файлы Qt Designer
    └── mainwindow.ui
```

## Требования

- Qt 5.15 или выше
- CMake 3.16 или выше
- C++17

## Сборка

### Linux/macOS

```bash
mkdir build
cd build
cmake ..
make
```

### Windows (Visual Studio)

```cmd
mkdir build
cd build
cmake .. -G "Visual Studio 16 2019"
cmake --build . --config Release
```

### Windows (MinGW)

```cmd
mkdir build
cd build
cmake .. -G "MinGW Makefiles"
cmake --build .
```

## Использование

1. Запустите приложение
2. Введите исходный код ассемблера в левое верхнее поле
3. Настройте таблицу команд в левом нижнем поле (по умолчанию загружены стандартные команды)
4. Нажмите "Первый проход" для выполнения первого прохода ассемблера
5. Нажмите "Второй проход" для генерации объектного кода

## Поддерживаемые директивы

- `START` - начало программы
- `END` - конец программы
- `WORD` - определение слова (3 байта)
- `BYTE` - определение байта или строки
- `RESW` - резервирование слов
- `RESB` - резервирование байтов

## Поддерживаемые команды

По умолчанию поддерживаются следующие команды:

- `JMP` (код 1, длина 4) - безусловный переход
- `LOADR1` (код 2, длина 4) - загрузка в регистр R1
- `LOADR2` (код 3, длина 4) - загрузка в регистр R2
- `ADD` (код 4, длина 2) - сложение
- `SAVER1` (код 5, длина 4) - сохранение регистра R1
- `INT` (код 6, длина 2) - прерывание

## Формат команд

Команды задаются в формате: `ИМЯ КОД ДЛИНА`, где:
- ИМЯ - название команды (латинские буквы и цифры)
- КОД - шестнадцатеричный код команды (0-FF)
- ДЛИНА - длина команды в байтах (1, 2 или 4)

## Пример исходного кода

```
PROG  START   100
    JMP     L1 
B1  WORD    40 
B3  BYTE    C"Hello!"
B4  BYTE    12	
L1  LOADR1  B1	
    LOADR2  B4
    ADD R1  R2
    SAVER1  B1
    INT     200	
    END
```

## Детальное описание структуры кода

### Архитектура

#### 1. **Структуры данных** (`include/structures/`, `src/structures/`)

**Command** (`command.h/cpp`)
- Представляет команду ассемблера
- Содержит: имя команды, код операции, длину в байтах
- Валидация: имя должно начинаться с буквы, код 0-255, длина 1/2/4 байта
- Методы: `getName()`, `getCode()`, `getLength()`, `isValid()`

**Operand** (`operand.h/cpp`)
- Представляет операнд команды
- Использует `std::variant<std::string, int>` для хранения значения
- Методы: `getStringValue()`, `getIntValue()`, `isString()`, `isInt()`

**SymbolicName** (`symbolicname.h/cpp`)
- Представляет символическое имя (метку) в таблице символов
- Содержит: имя метки и её адрес
- Методы: `getName()`, `getAddress()`, `setName()`, `setAddress()`

**CodeLine** (`codeline.h/cpp`)
- Представляет строку исходного кода
- Содержит: метку (опционально), команду, первый операнд (опционально), второй операнд (опционально)
- Методы: `hasLabel()`, `hasFirstOperand()`, `hasSecondOperand()`

#### 2. **Парсер** (`include/parser/`, `src/parser/`)

**Parser** (`parser.h/cpp`)
- Статический класс для парсинга исходного кода
- **`parseCode()`** - разбивает текст на токены с помощью регулярных выражений
- **`textToCommands()`** - парсит таблицу команд из текста
- **`parseCodeLine()`** - парсит строку кода в структуру CodeLine
- **`parseFirstPassLine()`** - парсит результат первого прохода
- **`isCommandOrDirective()`** - определяет, является ли токен командой или директивой

#### 3. **Ассемблер** (`include/assembler/`, `src/assembler/`)

**Assembler** (`assembler.h/cpp`) - основной класс двухпросмотрового ассемблера

**Первый проход** (`firstPass()`):
- Создает таблицу символических имен (TSI)
- Обрабатывает директивы: START, END, WORD, BYTE, RESW, RESB
- Валидирует команды и операнды
- Проверяет переполнение памяти
- Генерирует промежуточный код с адресами

**Второй проход** (`secondPass()`):
- Разрешает символические ссылки
- Генерирует объектный код
- Создает записи H (Header), T (Text), E (End)

**Методы обработки директив:**
- `processStartDirective()` - устанавливает начальный адрес
- `processWordDirective()` - резервирует 3 байта для слова
- `processByteDirective()` - резервирует байт или строку
- `processReswDirective()` - резервирует слова
- `processResbDirective()` - резервирует байты
- `processEndDirective()` - устанавливает точку входа

**Вспомогательные методы:**
- `isCommand()`, `isDirective()`, `isLabel()` - проверка типов токенов
- `isRegister()` - проверка регистров R1-R16
- `isCString()`, `isXString()` - проверка строковых констант
- `overflowCheck()` - проверка переполнения памяти
- `convertToASCII()` - преобразование строки в ASCII hex

#### 4. **Пользовательский интерфейс** (`include/ui/`, `src/ui/`)

**MainWindow** (`mainwindow.h/cpp`)
- Главное окно приложения
- Использует UI файл `mainwindow.ui` для интерфейса
- **`onFirstPassClicked()`** - обработчик кнопки первого прохода
- **`onSecondPassClicked()`** - обработчик кнопки второго прохода
- **`initializeDefaultContent()`** - инициализация содержимого по умолчанию

**UI элементы:**
- `sourceCodeTextEdit` - ввод исходного кода
- `commandsTextEdit` - таблица команд
- `firstPassTextEdit` - результат первого прохода
- `tsiTextEdit` - таблица символических имен
- `firstPassErrorsTextEdit` - ошибки первого прохода
- `secondPassTextEdit` - результат второго прохода
- `secondPassErrorsTextEdit` - ошибки второго прохода
- `firstPassButton` - кнопка первого прохода
- `secondPassButton` - кнопка второго прохода

#### 5. **Исключения** (`include/exceptions/`, `src/exceptions/`)

**AssemblerException** (`assemblerexception.h/cpp`)
- Наследуется от `std::runtime_error`
- Используется для всех ошибок ассемблера
- Конструкторы: по умолчанию, с сообщением, с сообщением и внутренним исключением

#### 6. **Точка входа** (`src/main.cpp`)

**main()**
- Создает QApplication
- Создает и показывает MainWindow
- Запускает цикл обработки событий Qt

### Алгоритм работы ассемблера

#### Первый проход:
1. **Инициализация**: очистка TSI, установка ip=0
2. **Парсинг строк**: разбор исходного кода на токены
3. **Обработка меток**: добавление в TSI с текущим адресом
4. **Обработка директив**:
   - START: установка начального адреса
   - WORD: резервирование 3 байт
   - BYTE: резервирование байта/строки
   - RESW/RESB: резервирование памяти
   - END: установка точки входа
5. **Обработка команд**: генерация кода с адресами
6. **Валидация**: проверка ошибок и переполнения

#### Второй проход:
1. **Парсинг первого прохода**: разбор промежуточного кода
2. **Генерация заголовка**: создание H-записи
3. **Обработка команд**: разрешение символических ссылок
4. **Генерация объектного кода**: создание T-записей
5. **Завершение**: создание E-записи

### Ключевые особенности реализации

- **Двухпросмотровая архитектура**: первый проход создает TSI, второй генерирует код
- **Валидация на каждом этапе**: проверка синтаксиса, семантики, переполнения
- **Поддержка всех типов операндов**: числа, метки, регистры, строки
- **Гибкая система команд**: настраиваемая таблица команд
- **Обработка ошибок**: детальные сообщения об ошибках
